'''
Created on Mar 19, 2018

@author: ashaman
'''

import sys
import logging

class ProcessTree(object):
    '''
    Manages a tree view of the processes in the database
    '''

    MAX_TREE_LEVEL = 5

    def __init__(self):
        '''
        Constructor
        '''
        self.psTree = {}
        self.dbConn = None
        self.root_processes = []
        self.debug = False
        self.logger = logging.getLogger('MalwareAnalyzerShell.analyzers.CodeInjectionAnalyst')
        self.jsonOutputPlugin = None


    def setConnection(self, connection):
        self.dbConn = connection
        self.cursor = connection.cursor()

    def __isPIDReused(self, pid):
        return self.cursor.execute("SELECT COUNT(*) FROM process WHERE pid = %s" % pid).fetchone()[0] > 1


    def initializeTree(self):
        self.psTree = {}
        self.root_processes = []

        #the root of the process tree should be all process that don't have parents
        resp = self.cursor.execute("SELECT id FROM process WHERE pp_id IS NULL")
        for row in resp:
            self.root_processes.append(row[0])

        for p_id in self.root_processes:
            self.__build_pstree(p_id)

    def __build_pstree(self, p_id):
        children = []

        resp = self.cursor.execute("SELECT id FROM process WHERE pp_id = %s" % p_id).fetchall()
        for row in resp:
            children.append(row[0])

        self.psTree[p_id] = children

        for child in children:
            self.__build_pstree(child)

    def __compute_ancestor_path(self, path_filter, roots, p_id):
        pp_id = self.cursor.execute("SELECT pp_id FROM process WHERE id = %s" % p_id).fetchone()[0]
        if pp_id:
            if(pp_id not in path_filter):
                path_filter[pp_id] = []

            if(p_id not in path_filter[pp_id]):
                path_filter[pp_id].append(p_id);

            self.__compute_ancestor_path(path_filter, roots, pp_id)
        elif not p_id in roots:
            roots.append(p_id)

    def __getProcessNodeDescription(self, p_id, json_node):
        row = self.cursor.execute("SELECT id, pid, COALESCE(image, ''), \
            desc_address FROM process WHERE id = %s" % p_id).fetchone()

        desc = "%s (%s) %s" % (row[1], row[3], row[2])
        json_node["PID"] = row[1]
        json_node["Descriptor Address"] = row[3]
        json_node["Image"] = row[2]

        if self.debug:
            #include the row id also
            desc = "%s [row_id = %s]" % (desc, row[0])

        return desc

    def __printTree(self, node, path_filter, mitData, json_node, level, indent='   '):
        if level > self.MAX_TREE_LEVEL:
          return

        if node not in self.psTree:
            return
        if not self.psTree[node]:
            return
        for child in self.psTree[node]:
            if node in path_filter and not child in path_filter[node]:
                continue

            json_child = {"children":[]}
            json_node["children"].append(json_child)
            if node in mitData and child in mitData[node]:
              json_node["Bond"] = "STRONG"
              self.writeTreeNode(indent + '|#####[%s] type = %s\n' %
                (self.__getProcessNodeDescription(child, json_child), ",".join(mitData[node][child])))
            else:
              json_child["Bond"] = "WEAK"
              self.writeTreeNode(indent + '|-----%s\n' % self.__getProcessNodeDescription(child, json_child))

            self.__printTree(child, path_filter, mitData, json_child, level + 1, indent + '     | ')

        if node in mitData:
          for target in mitData[node]:
              if target not in self.psTree[node]:
                #don't show target if a direct descendant, that is shown above
                json_child = {"Bond":"STRONG", "children":[]}
                json_node["children"].append(json_child)
                self.writeTreeNode(indent + '|*****[%s] type=%s\n' %
                   (self.__getProcessNodeDescription(target, json_node), ",".join(mitData[node][target])))


    def printTree(self, filterByProcess=None, mitData={}):
        '''
        Prints the process tree and optionally only shows the
        ancestors and descendants of the specified process
        '''

        path_filter = {}
        roots = self.root_processes
        json_tree = []
        if filterByProcess:

            process_filter = ""
            try:
                int(filterByProcess)
                process_filter = "WHERE pid = %s" % filterByProcess
            except ValueError:
                process_filter = "WHERE desc_address = '%s'" % filterByProcess

            roots = []
            resp = self.cursor.execute("SELECT id FROM process %s" % process_filter).fetchall()

            for row in resp:
                self.__compute_ancestor_path(path_filter, roots, row[0])

        for p_id in roots:
            json_node = {"children":[]}
            json_tree.append(json_node)
            self.printTreeNode(self.__getProcessNodeDescription(p_id, json_node))
            self.__printTree(p_id, path_filter, mitData, json_node, 0)

        if self.jsonOutputPlugin:
          self.jsonOutputPlugin.setTreeData(roots, json_tree)

    def isRelated(self, p_id1, p_id2):
        ancestorsP1 = {}
        ancestorsP2 = {}
        self.__compute_ancestor_path(ancestorsP1, [], p_id1)
        self.__compute_ancestor_path(ancestorsP2, [], p_id2)

        self.logger.debug("Ancestor p_ids for %d:  %s" % (p_id1, ",".join([str(p) for p in ancestorsP1.keys()])))
        self.logger.debug("Ancestor p_ids for %d:  %s" % (p_id2, ",".join([str(p) for p in ancestorsP2.keys()])))

        #parent/child relationship
        related = p_id1 in ancestorsP2 or p_id2 in ancestorsP1

        if related:
            return True
        else:
            #siblings??
            common_ancestors = list(set(ancestorsP1) & set(ancestorsP2))
            self.logger.debug("Common ancestors are:  %s" % (",".join([str(p) for p in common_ancestors])))

            if common_ancestors:
                '''
                if the common ancestors are root processes, then they are not related;
                we don't want 2 processes created by explorer.exe to be considered related;
                '''
                for common in common_ancestors:
                    pp_id = self.cursor.execute("SELECT pp_id FROM process WHERE id = %s" % common).fetchone()[0]
                    if pp_id:
                        return True
            else:
                return False

    def isRootProcess(self, p_id):
        '''
        Returns if this process is a Windows System process, i.e. it
        is doesn't have a parent process
        '''
        return p_id in self.root_processes

    def getNonRootParentId(self, p_id):
        pp_id = self.cursor.execute("SELECT pp_id FROM process WHERE id = %s" % p_id).fetchone()[0]
        if pp_id in self.root_processes:
            return None
        else:
            return pp_id

    def __getAllProcessesPostOrder(self, processes, p_id):
        for child in self.psTree[p_id]:
            self.__getAllProcessesPostOrder(processes, child)
        processes.append(p_id)

    def getAllProcessesPostOrder(self):
        processes = []
        for p_id in self.root_processes:
            self.__getAllProcessesPostOrder(processes, p_id)

        return processes

    def printTreeNode(self, nodeDescription):
      if not self.jsonOutputPlugin:
        print(nodeDescription)

    def writeTreeNode(self, nodeDescription):
      if not self.jsonOutputPlugin:
        sys.stdout.write(nodeDescription)

    def setJSONOutputPlugin(self, outputPlugin):
      self.jsonOutputPlugin = outputPlugin

    def setDebug(self, mode):
        self.debug = mode

