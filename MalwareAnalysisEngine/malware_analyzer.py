#!/usr/bin/env python
# encoding: utf-8

'''
Created on Mar 11, 2018

@author: ashaman
'''

import cmd, sys, sqlite3, glob, os, logging
from pathlib import Path
from sqlite3 import DatabaseError
from beautifultable import BeautifulTable
from analyzers.AnalysisEngine import AnalysisEngine
from utils.process_tree import ProcessTree
import build_database
import readline
from utils.utilities import banner

def _append_slash_if_dir(p):
    if p and os.path.isdir(p) and p[-1] != os.sep:
        return p + os.sep
    else:
        return p

class MalwareAnalyzerShell(cmd.Cmd):
    CONST_DEFAULT_PROMPT = '(malware)> '
    intro = "Welcome to the DbgView Malware Analyzer shell.  Type help or ? to list commands.\n"
    prompt = CONST_DEFAULT_PROMPT

    def __init__(self):
        super(MalwareAnalyzerShell, self).__init__()
        self.processTree = ProcessTree()
        self.analysisEngine = AnalysisEngine(self.processTree)
        self.process_context = None
        self.sqlite_conn = None
        self.debug = False
        self.reportRootProcessAnalysis = False

    def setOutputPlugin(self, outputPlugin):
      self.analysisEngine.setOutputPlugin(outputPlugin)
      self.processTree.setJSONOutputPlugin(outputPlugin)

    def do_load_db(self, arg, mute = False):
        'Load a database that contains parsed DbgView logs for analysis'

        if not Path(arg).is_file():
            sys.stderr.write("The input file, %s, is not a file or doesn't exist\n" % arg)
            return

        self.sqlite_conn = sqlite3.connect(arg)

        #ensure it is an actual DB
        try:
            self.sqlite_conn.execute("SELECT 1 FROM process")
            if not mute: print("Database %s successfully loaded\n" % arg)
            self.processTree.setConnection(self.sqlite_conn)
            self.processTree.initializeTree()
        except DatabaseError:
            sys.stderr.write("The specified file, %s, is not a sqlite database\n" % arg)
        return

    def do_load_log(self, arg):
        'Parse the specified DbgView log file into a malware database'

        if not Path(arg).is_file():
            sys.stderr.write("The input file, %s, is not a file or doesn't exist\n" % arg)
            return

        filename, _ = os.path.splitext(arg)
        filename = "%s.sql" % filename

        if(os.path.isfile(filename)):
            overwrite = input("The file in which the malware database will be saved already exists, %s, overwrite it? (y/n): " % filename) == "y"
            if(not overwrite):
                return
            os.remove(filename)

        build_database.buildMalwareDatabase([arg], filename)

        print("\nMalware database file %s successfully created" % filename)

        self.do_load_db(filename)

    def do_grep_ls(self, arg):
        '''
        Searches for operations involving the specified file filter

        Example:
        grep_ls *Virus.exe*
        '''

        if not arg:
            sys.stderr.write("Please specify a file filter\n")
            return

        return self.do_ls(arg)

    def do_ls(self, arg):
        '''
        List the file resources contained in the database.
        The returned files can be filtered by using globs.  Example:  ls *ntdll.dll*

        If in a process context (via ps_cd <pid>), shows only the file resources accessed by this process
        in addition to the type of access, i.e. READ, WRITE, etc.  You can also filter for specific files
        in this context using ls *NickVirus*
        '''

        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if self.prompt == self.CONST_DEFAULT_PROMPT:
            query = "SELECT id, name, first_seen FROM resource WHERE type = 'F'"
            cursor = self.sqlite_conn.cursor()

            arg = arg.strip()
            if arg:
                query = "SELECT id, name, first_seen FROM resource WHERE type = 'F' AND name LIKE '%s'" % arg.replace("*", "%")

            try:
                table = BeautifulTable(max_width=160)
                table.column_headers = ["Resource Id", "Name", "First Seen"]
                for row in cursor.execute(query):
                    table.append_row(row)

                if not len(table):
                    sys.stderr.write("No file with name %s found\n" % arg)
                    return

                print(table)
                print("\n")
                print("Total:  %d\n" % len(table))

                if arg:
                    table.clear(True)
                    table.column_headers = ["Time", "PID", "Process Descriptor", "Process Image", "Target PID", "Target Descriptor", "Target Image", "Operation", "Aux Data"]
                    for row in cursor.execute("SELECT time, p1.pid, p1.desc_address, COALESCE(p1.image, ''), \
                                COALESCE(p2.pid, ''), COALESCE(p2.desc_address, ''), COALESCE(p2.image, ''), op, COALESCE(data,'') \
                                 FROM operation JOIN process p1 ON p_id = p1.id LEFT JOIN \
                                 process p2 ON target_p_id = p2.id JOIN resource ON \
                                 r_id = resource.id WHERE name LIKE '%s'" % arg.replace("*", "%")):
                        table.append_row(row)

                    if len(table):
                        print("Accessed by process(es) ...")
                        print(table)
                        print("\n")
                        print("Total:  %d\n" % len(table))
            except Exception as e:
                print(e)
                sys.stderr.write("Invalid file name specified")
        else:
            searchOnNameClause = ""
            arg = arg.strip()
            if arg:
                searchOnNameClause = "AND name LIKE '%s'" % arg.replace("*", "%")

            process_filter = ""
            try:
                int(self.process_context)
                process_filter = "WHERE pid = %s" % self.process_context
            except:
                process_filter = "WHERE desc_address = '%s'" % self.process_context

            cursor = self.sqlite_conn.cursor()

            resp = cursor.execute("SELECT id, pid, desc_address FROM process %s" % process_filter).fetchall()
            for pRow in resp:
                '''
                This query accounts for both image loads + file i/o
                '''
                query = "SELECT name, COALESCE(op, ''), COALESCE(process.pid, ''), COALESCE(desc_address, ''), COALESCE(data, ''), \
                time FROM operation LEFT JOIN process ON target_p_id = process.id JOIN \
                resource ON r_id = resource.id WHERE target_p_id = %s AND type = 'F' %s  \
                UNION \
                SELECT name, COALESCE(op, ''), '', '', COALESCE(data, ''), \
                time FROM operation JOIN process ON p_id = process.id JOIN \
                resource ON r_id = resource.id WHERE p_id = %s AND type = 'F' AND target_p_id IS NULL %s ORDER BY time" % \
                (pRow[0], searchOnNameClause, pRow[0], searchOnNameClause)

                print("\n")
                print(banner("Process %s (%s)" % (pRow[1], pRow[2])))
                table = BeautifulTable(max_width=160)
                table.column_headers = ["Name", "Operation", "Target PID", "Target PID Descriptor", "Aux Data", "First Seen"]
                for row in cursor.execute(query):
                    table.append_row(row)

                print(table)
                print("Total:  %d\n" % len(table))

    def do_ps_ls(self, arg):
        '''
            Display all the files accessed by the specified process
            If you also want to filter on the file name, then use
            ps_cd to establish a process context then ls <file_name_filter>

            Examples:
            ps_ls <pid>
            ps_ls <descriptor address>
        '''

        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        arg = arg.strip()
        process_filter = ""

        if(arg):
            try:
                int(arg)
                process_filter = "WHERE pid = %s" % arg
            except ValueError:
                process_filter = "WHERE desc_address = '%s'" % arg
        else:
            sys.stderr.write("Please specify a process PID or descriptor address\n")
            return

        cursor = self.sqlite_conn.cursor()

        resp = cursor.execute("SELECT id, pid, desc_address FROM process %s" % process_filter).fetchall()
        for pRow in resp:
            '''
            This query accounts for both image loads + file i/o
            '''
            query = "SELECT name, COALESCE(op, ''), COALESCE(process.pid, ''), COALESCE(desc_address, ''), COALESCE(data, ''), \
            time FROM operation LEFT JOIN process ON target_p_id = process.id JOIN \
            resource ON r_id = resource.id WHERE target_p_id = %s AND type = 'F'  \
            UNION \
            SELECT name, COALESCE(op, ''), '', '', COALESCE(data, ''), \
            time FROM operation JOIN process ON p_id = process.id JOIN \
            resource ON r_id = resource.id WHERE p_id = %s AND type = 'F' AND target_p_id IS NULL ORDER BY time" % \
            (pRow[0], pRow[0])

            table = BeautifulTable(max_width=160)
            table.column_headers = ["Name", "Operation", "Target PID", "Target PID Descriptor", "Aux Data", "First Seen"]
            for row in cursor.execute(query):
                table.append_row(row)

            print("\n")
            print(banner("Process %s (%s)" % (pRow[1], pRow[2])))
            print(table)
            print("Total:  %d\n" % len(table))

    def do_ps_cd(self,arg):
        '''
        Set a process context to discover the resources accessed by the process.
        Specifying ps_cd without any arguments will exit the process context

        Examples:
        ps_cd <pid>
        ps_cd <descriptor address>
        '''

        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        arg = arg.strip()
        process_filter = ""
        is_pid = False
        if(arg):
            try:
                int(arg)
                is_pid = True
                process_filter = "WHERE pid=%s" % arg
            except ValueError:
                process_filter = "WHERE desc_address='%s'" % arg
        else:
            self.prompt = self.CONST_DEFAULT_PROMPT
            self.process_context = None
            return

        cursor = self.sqlite_conn.cursor()
        row = cursor.execute("SELECT pid, desc_address FROM process %s" % process_filter).fetchone()
        if(row):
            self.process_context = arg
            if is_pid:
                self.prompt = "(Process %s)> " % (row[0])
            else:
                self.prompt = "(Process %s %s)> " % (row[0], row[1])
        else:
            sys.stderr.write("Unknown process PID or descriptor specified:  %s\n" % arg)


    def do_ps(self, arg):
        '''
        List the processes contained in the database or
        list the details for a particular process using its PID or
        descriptor address.
        Note that if you use the PID, due to the
        OS possibly reusing the PID, you may get more than one process back

        Examples:
        ps
        ps 4608
        ps 0x00000080
        '''

        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if not arg and self.process_context:
            arg = self.process_context

        arg = arg.strip()

        process_filter = ""
        if(arg):
            try:
                int(arg)
                process_filter = "WHERE p1.pid = %s" % arg
            except ValueError:
                #assume it is a descriptor
                process_filter = "WHERE p1.desc_address = '%s'" % arg


        query = "SELECT p1.pid, COALESCE(p1.desc_address, ''), COALESCE(p1.image, ''), \
                COALESCE(p2.pid, ''), COALESCE(p2.desc_address, ''), p1.first_seen, \
                COALESCE(p1.terminated_time, ''), \
                COALESCE(p1.suspicion_score, '') FROM process p1 \
                LEFT JOIN process p2 ON p1.pp_id = p2.id %s" % process_filter

        cursor = self.sqlite_conn.cursor()

        try:
            table = BeautifulTable(max_width=160)
            table.column_headers = ["PID", "Descriptor Address", "Image", "Parent PID", "Parent Descriptor Address", "First Seen", "Terminated Time", "Suspicion Score"]
            for row in cursor.execute(query):
                table.append_row(row)

            print(table)
            print("\n")
        except Exception as e:
            print(e)
            sys.stderr.write("Invalid process id specified")


    def do_grep_ps(self, arg):
        '''
        Searches for a process based on its process image.  Ex:  psgrep *NickVirus*
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if not arg:
            sys.stderr.write("Please specify a process image filter\n")
            return

        cursor = self.sqlite_conn.cursor()
        resp = cursor.execute("SELECT desc_address FROM process WHERE image LIKE '%s'" % arg.replace("*", "%")).fetchall()

        if not len(resp):
            sys.stderr.write("No matching processes found\n")
            return
        else:
            for desc_address in resp:
                self.do_ps(desc_address[0])

    def do_ps_regs(self, arg):
        '''
        Lists the registry requests made by the specified process
        using the process PID or address descriptor.

        Note that if you use the PID, due to the
        OS possibly reusing the PID, you may get more than one process back

        Examples:
        ps_regs 4608
        ps_regs 0x00000073
        ps_regs if already in a process context (using ps_cd)
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if not arg:
            if self.process_context:
                arg = self.process_context
            else:
                sys.stderr.write("Please specify a process id or descriptor address\n")
                return

        arg = arg.strip()
        process_filter = ""
        if(arg):
            try:
                int(arg)
                process_filter = "WHERE pid = %s" % arg
            except ValueError:
                #assume its a process descriptor
                process_filter = "WHERE desc_address = '%s'" % arg

        cursor = self.sqlite_conn.cursor()
        resp = cursor.execute("SELECT id, desc_address, COALESCE(image,''), pid FROM process %s" % process_filter).fetchall()

        if not len(resp):
            sys.stderr.write("Invalid process pid, %s, specified\n" % arg)
            return

        table = BeautifulTable(max_width=160)
        for row in resp:
            table.column_headers = ["Time", "Operation", "Key", "Aux Data"]

            initiating = cursor.execute("SELECT time, op, name, COALESCE(data, '') FROM operation \
                JOIN resource ON r_id = resource.id WHERE p_id = %s AND type = 'R'" % row[0])
            for rowIni in initiating:
                table.append_row(rowIni)

            print("\n")
            print(banner("Process %s (%s)" % (row[3], row[1])))
            print("Image:  %s\n" % row[2])

            print("Registry Operations Initiated By This Process:")
            print(table)
            print("Total:  %d\n" % len(table))
            table.clear()

    def do_grep_regs(self, arg):
        '''
        Search all process registry requests by key name or value
        Ex:  grep_regs *MACHINE\SYSTEM*
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if not arg:
            if self.process_context:
                arg = self.process_context
            else:
                sys.stderr.write("Please specify a process id or descriptor address\n")
                return

        arg = arg.strip()
        cursor = self.sqlite_conn.cursor()

        table = BeautifulTable(max_width=160)
        table.column_headers = ["Time", "PID", "Process Descriptor", "Image", "Operation", "Key", "Aux Data"]

        regs = cursor.execute("SELECT time, pid, desc_address, COALESCE(image, ''), \
            op, name, COALESCE(data, '') FROM operation \
            JOIN resource ON r_id = resource.id JOIN process ON p_id = process.id \
            WHERE (name LIKE '%s' OR data LIKE '%s') AND type = 'R'" \
            % (arg.replace("*", "%"), arg.replace("*", "%")))

        for rowIni in regs:
            table.append_row(rowIni)

        print(table)
        print("Total:  %d\n" % len(table))
        table.clear()

    def do_ps_reqs(self, arg):
        '''
        Lists the process requests made by the specified process
        using the process PID or address descriptor.

        Note that if you use the PID, due to the
        OS possibly reusing the PID, you may get more than one process back

        Examples:
        ps_reqs 4608
        ps_reqs 0x00000073
        ps_reqs if already in a process context (using ps_cd)
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if not arg:
            if self.process_context:
                arg = self.process_context
            else:
                sys.stderr.write("Please specify a process id or descriptor address\n")
                return

        arg = arg.strip()
        process_filter = ""
        if(arg):
            try:
                int(arg)
                process_filter = "WHERE pid = %s" % arg
            except ValueError:
                #assume its a process descriptor
                process_filter = "WHERE desc_address = '%s'" % arg

        cursor = self.sqlite_conn.cursor()
        resp = cursor.execute("SELECT id, desc_address, COALESCE(image,''), pid FROM process %s" % process_filter).fetchall()

        if not len(resp):
            sys.stderr.write("Invalid process pid, %s, specified\n" % arg)
            return

        table = BeautifulTable(max_width=160)
        for row in resp:
            table.column_headers = ["Time", "Operation", "Target PID", "Target Descriptor", "Target Image"]

            initiating = cursor.execute("SELECT time, data, pid, desc_address, COALESCE(image, '') FROM operation \
                JOIN process ON target_p_id = process.id WHERE p_id = %s AND op = 'PROCESS-ACCESS-REQ'" % row[0])
            for rowIni in initiating:
                table.append_row(rowIni)

            print("\n")
            print(banner("Process %s (%s)" % (row[3], row[1])))
            print("Image:  %s\n" % row[2])

            print("Operations Initiated By This Process:")
            print(table)
            print("Total:  %d\n" % len(table))
            table.clear()

            table.column_headers = ["Time", "Operation", "Initiator PID", "Initiator Descriptor", "Initiator Image"]

            initiating = cursor.execute("SELECT time, data, pid, desc_address, COALESCE(image, '') FROM operation \
                JOIN process ON p_id = process.id WHERE target_p_id = %s AND op = 'PROCESS-ACCESS-REQ'" % row[0])
            for rowIni in initiating:
                table.append_row(rowIni)

            print("\nOperations In Which This Process Is The Target:")
            print(table)
            print("Total:  %d\n" % len(table))
            table.clear()

    def do_grep_ps_reqs(self, arg):
        '''
        Search all process requests by the image name of the initiator or target process
        Ex:  ps_reqs_grep *wordpad*
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        if not arg:
            sys.stderr.write("Please specify the image name to search\n")
            return

        process_context_filter = ""
        if self.process_context:
            try:
                int(self.process_context)
                process_context_filter = "(p1.pid = %s OR p2.pid = %s) AND " % \
                    (self.process_context, self.process_context)
            except:
                process_context_filter = "(p1.desc_address = '%s' OR p2.desc_address = '%s') AND " % \
                    (self.process_context, self.process_context)

        cursor = self.sqlite_conn.cursor()
        arg = arg.strip()

        table = BeautifulTable(max_width=160)
        table.column_headers = ["Time", "Operation", "Initiator PID", "Initiator Descriptor", "Initiator Image", "Target PID", "Target Descriptor", "Target Image"]

        initiating = cursor.execute("SELECT time, data, p2.pid, p2.desc_address, COALESCE(p2.image, ''), \
            p1.pid, p1.desc_address, COALESCE(p1.image, '') FROM operation \
            JOIN process p1 ON target_p_id = p1.id JOIN process p2 ON p_id = p2.id \
            WHERE %s (p1.image LIKE '%s' OR p2.image LIKE '%s') AND op = 'PROCESS-ACCESS-REQ'"
            % (process_context_filter, arg.replace("*", "%"), arg.replace("*", "%")))

        for rowIni in initiating:
            table.append_row(rowIni)

        print(table)
        print("Total:  %d\n" % len(table))


    def do_pstree(self, arg):
        '''
        Lists the processes in the database as a tree
        pstree to show all processes
        pstree <pid> to show the tree for all processes with the matching PID
        pstree <desc address> to show the tree for the specified process
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        cursor = self.sqlite_conn.cursor()

        if(arg):
            process_filter = ""
            try:
                int(arg)
                process_filter = "WHERE pid = %s" % arg
            except ValueError:
                process_filter = "WHERE desc_address = '%s'" % arg

            resp = cursor.execute("SELECT id FROM process %s" % process_filter).fetchall()

            if not len(resp):
                sys.stderr.write("Process with PID or descriptor address %s not found\n" % arg)
                return

        print("\n")
        self.processTree.printTree(arg)
        print("\n")


    def do_mittree(self, arg):
        '''
        Displays the Malware Infection tree
        mittree to show all processes
        mittree <pid> to show the tree for all processes with the matching PID
        mittree <desc address> to show the tree for the specified process
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        cursor = self.sqlite_conn.cursor()

        sus_data = cursor.execute("SELECT COUNT(*) FROM suspicious_behavior").fetchone()
        if(sus_data[0] == 0):
            sys.stderr.write("The database doesn't seem to contain malware behavior analysis data, did you run the analyze command?\n")
            return

        cursor = self.sqlite_conn.cursor()

        if(arg):
            process_filter = ""
            try:
                int(arg)
                process_filter = "WHERE pid = %s" % arg
            except ValueError:
                process_filter = "WHERE desc_address = '%s'" % arg

            resp = cursor.execute("SELECT id FROM process %s" % process_filter).fetchall()

            if not len(resp):
                sys.stderr.write("Process with PID or descriptor address %s not found\n" % arg)
                return

#         print("\n")
        mitData = self.analysisEngine.get_mit_data(cursor, self.reportRootProcessAnalysis)
        self.processTree.printTree(arg, mitData)
#         print("\n")

    def do_netdns(self, arg):
      '''
      Displays all DNS operations
      netdns
      netdns <Query ID>

      Example:
      netdns 0xFCF5
      '''

      return self.netdns_filter(arg, None)

    def do_grep_netdns(self, arg):
        '''
        Searches for DNS operations involving the specified host

        Example:
        grep_netdns *virustotal.com*
        '''

        if not arg:
            sys.stderr.write("Please specify a file filter\n")
            return

        return self.netdns_filter(None, arg)


    def netdns_filter(self, queryid, host):
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        cursor = self.sqlite_conn.cursor()

        qFilter = ""
        if queryid:
          queryid = queryid.strip()
          qFilter = "WHERE query_id = '%s'" % queryid
        elif host:
          host = host.strip()
          qFilter = "WHERE host LIKE '%s'" % host.replace("*", "%")

        resp = cursor.execute("SELECT time, COALESCE(pid, ''), COALESCE(desc_address, ''), query_id, op, COALESCE(host, ''),"
                              " COALESCE(data, 'N/A') FROM dns_operation LEFT JOIN process ON p_id = process.id %s" % qFilter).fetchall()

        table = BeautifulTable(max_width=160)
        table.column_headers = ["Time", "PID", "Descriptor", "Query ID", "Type", "Host", "Status"]

        for row in resp:
          table.append_row(row)

        print(table)
        print("Total:  %d\n" % len(table))


    def do_netstat(self, arg):
      '''
      Display the TCP connections contained in the database
      Example:
      netstat
      netstat <pid>
      netstat <descriptor address>
      '''
      if(self.sqlite_conn is None):
          sys.stderr.write("Please load a database first with the load_db command\n")
          return

      cursor = self.sqlite_conn.cursor()

      process_filter = ""
      if(arg):
          try:
              int(arg)
              process_filter = "WHERE pid = %s" % arg
          except ValueError:
              process_filter = "WHERE desc_address = '%s'" % arg

      resp = cursor.execute("SELECT time, COALESCE(pid, ''), COALESCE(desc_address, ''), COALESCE(image, ''), src_host, src_port, dst_host, dst_port, data"
                            " FROM tcp_operation LEFT JOIN process ON p_id = process.id %s" % process_filter).fetchall()

      table = BeautifulTable(max_width=160)
      table.column_headers = ["Time", "PID", "Descriptor", "Image", "Source Host", "Source Port", "Dest Host", "Dest Port", "Aux Data"]

      for row in resp:
        table.append_row(row)

      print(table)
      print("Total:  %d\n" % len(table))

    def do_analyze(self, noprompt):
        'Analyzes the database to detect processes that behave like malware'

        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        cursor = self.sqlite_conn.cursor()

        if not noprompt:
          sus_data = cursor.execute("SELECT COUNT(*) FROM suspicious_behavior").fetchone()
          if(sus_data[0] > 0):
              reanalyze = input("The processes in this database have already been analyzed for suspicious behavior.  Reanalyze? (y/n): ") == "y"
              if(not reanalyze):
                  return

        self.analysisEngine.analyze_processes(cursor)

        self.sqlite_conn.commit()

        print("\nAnalysis complete ...\n")

        sus_data = cursor.execute("SELECT COUNT(*) FROM suspicious_behavior").fetchone()
        if(sus_data[0] == 0):
            sys.stderr.write("There were no suspicious processes detected!\n\n")
            return

        self.do_report('')

    def do_report_analysts(self, arg):
      '''
      Displays for each analyst plugin, the processes that it detected
      suspicious behavior along with the suspicion score that analyst assigned
      to the process
      '''

      if(self.sqlite_conn is None):
          sys.stderr.write("Please load a database first with the load_db command\n")
          return

      cursor = self.sqlite_conn.cursor()

      sus_data = cursor.execute("SELECT COUNT(*) FROM suspicious_behavior").fetchone()
      if(sus_data[0] == 0):
          sys.stderr.write("The database doesn't seem to contain malware behavior analysis data, did you run the analyze command?\n")
          return

      self.analysisEngine.print_analyst_report(cursor, self.reportRootProcessAnalysis)

    def queryMalwareDatabase(self, query):
        cursor = self.sqlite_conn.cursor()
        results = cursor.execute(query)
        return results

    def getSuspicionRating(self, score):
      return self.analysisEngine.getSuspicionRating(score)

    def do_report(self, arg):
        '''
        Reports the results of analyzing the specified database for processes
        with suspicious behavior

        Examples:
        report - shows a summary of all processes
        report <pid> - shows the details for all processes with the specified PID
        report <desc address> - shows the details for the specified process
        '''
        if(self.sqlite_conn is None):
            sys.stderr.write("Please load a database first with the load_db command\n")
            return

        cursor = self.sqlite_conn.cursor()

        sus_data = cursor.execute("SELECT COUNT(*) FROM suspicious_behavior").fetchone()
        if(sus_data[0] == 0):
            sys.stderr.write("The database doesn't seem to contain malware behavior analysis data, did you run the analyze command?\n")
            return

        process_ids = None
        if(arg):
            process_filter = ""
            try:
                int(arg)
                process_filter = "WHERE pid = %s" % arg
            except ValueError:
                process_filter = "WHERE desc_address = '%s'" % arg

            process_ids = []
            resp = cursor.execute("SELECT id FROM process %s" % process_filter)
            for row in resp:
                process_ids.append(row[0])

            if not process_ids:
                sys.stderr.write("There is no process with pid or descriptor address %s in the database\n" % arg)
                return

        self.analysisEngine.print_report(cursor, process_ids, self.reportRootProcessAnalysis)

    def do_debug(self, arg):
        'Turn on debug logging'

        logger.setLevel(logging.DEBUG)
        ch.setLevel(logging.DEBUG)
        self.debug = True
        self.processTree.setDebug(True)
        print("Debug mode enabled")

    def do_no_debug(self, arg):
        'Disable debug logging'

        logger.setLevel(logging.INFO)
        ch.setLevel(logging.INFO)
        self.debug = False
        self.processTree.setDebug(False)
        print("Debug mode disabled")

    def do_exit(self, arg):
        'Exit the shell'
        return self.do_quit(arg)

    def do_quit(self, arg):
        'Exit the shell'
        print("Thank you for using DbgView Malware Analyzer shell")

        readline.write_history_file()
        return True

    def complete_file(self, text, line, begidx, endidx):
        if(self.sqlite_conn is None):
            return []

        before_arg = line.rfind(" ", 0, begidx)
        if before_arg == -1:
            return # arg not found

        arg = line[before_arg+1:endidx]
        arg = arg.strip()

        completions = []
        cursor = self.sqlite_conn.cursor()

        '''
        This function has been a real pain, difficult with hanlding
        backslashes and finally, can't seem to find
        a way to make readline case insensitive to support
        Windows paths.  Have to resortto using case sensitive completion!
        '''
        cursor.execute("PRAGMA case_sensitive_like = TRUE")
        for row in cursor.execute("SELECT name FROM resource WHERE name LIKE '%s%%' AND type = 'F'" % arg):
            name = row[0]
            completions.append(name)

        return completions

    def complete_ls(self, text, line, begidx, endidx):
        return self.complete_file(text, line, begidx, endidx)

    def complete_pid(self, text, line, begidx, endidx):
        if(self.sqlite_conn is None):
            return []

        before_arg = line.rfind(" ", 0, begidx)
        if before_arg == -1:
            return # arg not found

        arg = line[before_arg+1:endidx]

        completions = []
        cursor = self.sqlite_conn.cursor()

        for row in cursor.execute("SELECT pid FROM process WHERE pid LIKE '%s%%'" % arg):
            completions.append("%s" % row[0])

        return completions

    def do_enable_root_process_analaysis(self, arg):
        '''
        Enables including root processes (i.e. processes that do not
        have a parent process) when reporting on suspicious process
        behavior
        '''
        self.reportRootProcessAnalysis = True

    def do_disable_root_process_analaysis(self, arg):
        '''
        Enables including root processes (i.e. processes that do not
        have a parent process) when reporting on suspicious process
        behavior
        '''
        self.reportRootProcessAnalysis = False

    def complete_ps(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_ps_ls(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_ps_regs(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_ps_reqs(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_pstree(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_ps_cd(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_report(self, text, line, begidx, endidx):
        return self.complete_pid(text, line, begidx, endidx)

    def complete_load_db(self, text, line, begidx, endidx):
        before_arg = line.rfind(" ", 0, begidx)
        if before_arg == -1:
            return # arg not found

        fixed = line[before_arg+1:begidx]  # fixed portion of the arg
        arg = line[before_arg+1:endidx]
        pattern = arg + '*'

        completions = []
        for path in glob.glob(pattern):
            path = _append_slash_if_dir(path)
            completions.append(path.replace(fixed, "", 1))
        return completions

    def complete_load_log(self, text, line, begidx, endidx):
        return self.complete_load_db(text, line, begidx, endidx)


    def emptyline(self):
        pass

    def close(self):
      if self.sqlite_conn:
        self.sqlite_conn.commit()
        self.sqlite_conn.close();

if __name__ == '__main__':
    readline.set_completer_delims(' \t\n;')
    logger = logging.getLogger('MalwareAnalyzerShell')
    ch = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    malwareShell = MalwareAnalyzerShell()
    if("-v" in sys.argv or "--verbose" in sys.argv):
        malwareShell.do_debug("")

    if(len(sys.argv) == 3):
        malwareShell.do_load_db(sys.argv[2])
        malwareShell.do_analyze(True)
    elif(len(sys.argv) == 2):
        malwareShell.do_load_db(sys.argv[1])

    try:
        readline.read_history_file()
    except:
        pass
    malwareShell.cmdloop()