#!/usr/bin/env python
# encoding: utf-8
'''
build_database -- builds a sqlite database from DbgView output

build_database is a builds a sqlite database from DbgView output

generated by the Minispy filesystem filter

@author:     Nicholas Amon

@license:    license

@contact:    namon@andrew.cmu.edu
@deffield    updated: Updated
'''

import sys
import sqlite3
import re
import pprint

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter
from pathlib import Path
import traceback

__all__ = []
__version__ = 0.1
__date__ = '2018-02-25'
__updated__ = '2018-02-25'

DBGVIEW_REGEXES = {
                    "file_write":"\d+\t(.+)\t@@@ (IRP_MJ_WRITE), owner pid: (\d+), source address: (.+), destination file: (.*[\S])\s+",
                    "file_read":"\d+\t(.+)\t@@@ (IRP_MJ_READ), owner pid: (\d+), destination address: (.+), Source file: (.*[\S])\s+",
                    "file_delete":"\d+\t(.+)\t@@@ (IRP_MJ_SET_INFORMATION), owner pid: (\d+), destination file: (.+), disposition: deletepending",
                    "file_create":"\d+\t(.+)\t@@@ (IRP_MJ_CREATE), owner pid: (\d+), destination file: (.+), disposition: (\S+)",
                    "process-create":"\d+\s+(.+)\s+@@@\s+True[-\s+]Process-?Created,\s+pid:\s+(\d+),\s+ppid:\s+(\d+),\s+source\s+image\s+file\s+01:\s+(.+),\s+process:\s+(\S+)",
                    "process-terminated":"\d+\s+(.+)\s+@@@\s+Process-Terminated,\s+pid:\s+(\d+),\s+process:\s+(\S+)",
                    "image-load":"\d+\s+(.+)\s+@@@\s+image-loaded,\s+loaded full image name:\s+(.+),\s+target pid\s+(\d+),\s+injector pid (\d+),\s+image base address\s+(\S+)",
                    "process-access-req":"\d+\s+(.+)\s+@@@\s+Process-.+-(?:access)?attempt,\s+target pid:\s+(\d+),\s+.+\spid:\s+(\d+),\s+desired access:\s+(\S+)",
                    "reg-create-key":"\d+\s+(.+)\s+@@@\s+RegNtPreCreateKeyEx,\s+key:\s+(.*[\S]),\s+creator pid:\s+(\d+)",
                    "reg-delete-key":"\d+\s+(.+)\s+@@@\s+RegNtDeleteKey,\s+delete key:\s+(.*[\S]),\s*creator pid:\s+(\d+)",
                    "reg-rename-key":"\d+\s+(.+)\s+@@@\s+RegNtPreRenameKey,\s+old key name:\s+(.*[\S]),\s+new key name:\s+(.*[\S]),\s+creator pid:\s+(\d+)",
                    "reg-set-key-value":"\d+\s+(.+)\s+@@@\s+RegNtPreSetValueKey,\s+value key:\s+(.*[\S]),\s+creator pid:\s+(\d+), new value name:(.*[\S])\s+",
                    "reg-delete-key-value":"\d+\s+(.+)\s+@@@\s+RegNtDeleteValueKey,\s+deletekey:\s+(.*[\S]),\s+deletekeyvaluename:\s+(.*[\S]),\s+creator pid:\s+(\d+)",
                    "net-dns-request": ".+\d+/\d+/\d+\s+(\S+)\s+.+\s+DNS\s+DNS:QueryId = (\S+),.+,\sQuery\s+for\s+(\S+)",
                    "net-dns-response-success": ".+\d+/\d+/\d+\s+(\S+).+DNS\s+DNS:QueryId = (\S+),.+,\sResponse - Success, (.+)\s{DNS",
                    "net-dns-response-error": ".+\d+/\d+/\d+\s+(\S+).+DNS:QueryId = (\S+),.+,\sResponse - Name Error",
                    "net-tcp": "\d+\s+(\S+).+\d+/\d+/\d+\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+TCP\s+(.+),\s+SrcPort=(\S+),.+DstPort=(\S+),",
                    "net-tcp-no-pid": "\d+\s+.+\d+/\d+/\d+\s+(\S+)\s+(\S+)\s+(\S+)\s+TCP\s+(.+),\s+SrcPort=(\S+),.+DstPort=(\S+),",
                    "net-http": "\d+\s+(\S+).+\d+/\d+/\d+\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+HTTP\s+(.+){",
                    "net-http-request": "\d+\s+(\S+).+\d+/\d+/\d+\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+HTTP:Request,\s+(.+){",
                    "net-http-payload": "\d+\s+(\S+).+\d+/\d+/\d+\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+HTTP:HTTP Payload,\s+(.+){",
                    "net-http-response": "\d+\s+(\S+).+\d+/\d+/\d+\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+HTTP:Response,\s+(.+){",
                    "ignore": "(ARP:Request|ARP:Response|DHCP|NbtNs:Query|ICMP|IGMP|LLMNR|WSDiscovery|SSDP|NbtNs|BROWSER:|UDP:SrcPort|TLS:|SSL:|IPv6:|OCSP:)",
                }

reused_pids = []
seen_pids = {}
seen_file_resource_names = {}
seen_reg_resource_names = {}
drive_mappings = {}
warnings = {}
line_number = 0
current_line = None
showEmptyDBNetWarning = False
cursor = None
debug = False


'''
Need to ignore the descriptor addresses that are contained in the logs
since I have encountered cases where the combination of pid + descriptor address
is not unique in the log (i.e. DB unique constraint failed)
Since as we are parsing the log, we can track the lifecycle of a process
and therefore don't really need the descriptor address while parsing to differentiate
different incarnations of pids but it is useful for analysis.  As a result,
this script will generate its own unique descriptor address for every pid
'''
artifical_desc_address_count = 1

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg
    def __str__(self):
        return self.msg
    def __unicode__(self):
        return self.msg

def reset():
    global seen_pids, seen_file_resource_names, seen_reg_resource_names,\
        drive_mappings, artifical_desc_address_count,\
        reused_pids, warnings, line_number, current_line, showEmptyDBNetWarning

    reused_pids = []
    seen_pids = {}
    seen_file_resource_names = {}
    seen_reg_resource_names = {}
    drive_mappings = {}
    artifical_desc_address_count = 1
    warnings = {}
    line_number = 0
    current_line = None
    showEmptyDBNetWarning = False

def appendWarningMessage(msg):
  global line_number, warnings, current_line

  if not line_number in warnings:
      warnings[line_number] = [current_line]

  warnings[line_number].append(msg)

def appendNetWarningMessage(msg):
  global line_number, warnings, current_line

  if not line_number in warnings:
      warnings["net-%s" % line_number] = [current_line]

  warnings["net-%s" % line_number].append(msg)

def normalize_filename(filename):
    for key, val in drive_mappings.items():
        if filename.startswith(key):
            newFilename = filename[len(key):]
            newFilename = "%s%s" % (val, newFilename)
            return newFilename
    return filename

def normalize_regkey(key):
    if key.startswith("\SYSTEM"):
        return "%s%s" % ("\REGISTRY\MACHINE", key)
    if key.startswith("SYSTEM"):
        return "%s\%s" % ("\REGISTRY\MACHINE", key)
    return key

def insert_unseen_process(processId, firstSeen):
    global seen_pids, artifical_desc_address_count, cursor

    if processId in seen_pids:
        return seen_pids[processId]
    else:
        if "%s_%s" % (processId, "terminated") in seen_pids:
          appendWarningMessage("Process with pid %s is being reused after it was "
                               "terminated but there is no intervening create-process event" % processId)

        descriptorAddr = "0x%08X" % artifical_desc_address_count
        artifical_desc_address_count += 1
        cursor.execute("INSERT INTO process (pid, first_seen, desc_address) VALUES (%s, %s, '%s')"
                      % (processId, firstSeen, descriptorAddr))
        seen_pids[processId] = cursor.lastrowid
        return cursor.lastrowid

def insertIntoDatabase(r_type, data):
    global reused_pids, seen_pids, seen_file_resource_names,\
          seen_reg_resource_names, artifical_desc_address_count,\
          cursor, debug

    if debug:
      print("Resource Operation [%s]:  %s" % (r_type, data))

    ##In hindsight, should have used an ORM, this code will soon become difficult to maintain if it isn't already!
    if r_type == "ignore":
      pass
    elif r_type == "net-tcp-no-pid":
      if not 0 in seen_pids:
          insert_unseen_process(0, data[0])

      src_port = re.sub("\D", "", data[4])
      dst_port = re.sub("\D", "", data[5])

      cursor.execute("INSERT INTO tcp_operation (time, p_id, src_host, src_port, dst_host, dst_port, data) VALUES (%s, %s, '%s', %s, '%s', %s, '%s')"
           % (data[0], seen_pids[0], data[1], src_port, data[2], dst_port, data[3]))

    elif r_type == "net-tcp" or r_type.startswith("net-http"):
      pid = int(data[0], 0)
      if not pid in seen_pids:
          insert_unseen_process(pid, data[1])

      if r_type == "net-http" or r_type == "net-http-response":
        src_port = 80
        dst_port = 0 #unknown, not provided by netmon
      elif r_type == "net-http-request":
        src_port = 0
        dst_port = 80 #unknown, not provided by netmon
      elif r_type == "net-http-payload":
        src_port = 0
        dst_port = 0
      else:
        #strip off non-digits, e.g. HTTP(80) -> 80
        src_port = re.sub("\D", "", data[6])
        dst_port = re.sub("\D", "", data[7])

      cursor.execute("INSERT INTO tcp_operation (time, p_id, src_host, src_port, dst_host, dst_port, data) VALUES (%s, %s, '%s', %s, '%s', %s, '%s')"
                     % (data[1], seen_pids[pid], data[3], src_port, data[4], dst_port, data[5]))
      if pid in reused_pids:
        appendNetWarningMessage("Network activity occurred for a PID (%d) that is reused."
        "  The parser may not be able to accurately attribute the activity to the right process" % pid)

    elif r_type == "net-dns-request":
      cursor.execute("INSERT INTO dns_operation (time, query_id, op, host) VALUES (%s, '%s', 'REQUEST', '%s')" %
             (data[0], data[1], data[2]))
    elif r_type == "net-dns-response-success":
      hosts = []
      for addr in data[2].split():
        addr = addr.strip()
        if ',' in addr:
          addr = addr[:addr.find(',')]
        if not ".." in addr:
          hosts.append(addr)

      for host in hosts:
        cursor.execute("INSERT INTO dns_operation (time, query_id, op, data, host) VALUES (%s, '%s', 'RESPONSE', 'SUCCESS', '%s')" %
               (data[0], data[1], host))
    elif r_type == "net-dns-response-error":
        cursor.execute("INSERT INTO dns_operation (time, query_id, op, data) VALUES (%s, '%s', 'RESPONSE', 'ERROR')" %
               (data[0], data[1]))
    elif r_type == "process-create":
        if not data[2] in seen_pids:
            insert_unseen_process(data[2], data[0])

        if data[1] in seen_pids:
            appendWarningMessage("Process with pid %s is being reused (process-create) but there "
                                 "was no intervening process-termination for :  %s"  % (data[1], ",".join(data)))

            if data[1] not in reused_pids:
                reused_pids.append(data[1])
        else:
#             appendWarningMessage("Process with pid %s is being reused:  %s"  % (data[1], ",".join(data)))
            if data[1] not in reused_pids:
                reused_pids.append(data[1])

        image = normalize_filename(data[3])
        descriptorAddr = "0x%08X" % artifical_desc_address_count
        artifical_desc_address_count += 1
        cursor.execute("INSERT INTO process (first_seen, pid, pp_id, image, desc_address) VALUES (%s, %s, %s, '%s', '%s')" %
                       (data[0], data[1], seen_pids[data[2]], image, descriptorAddr))
        seen_pids[data[1]] = cursor.lastrowid

    elif r_type == "process-terminated":
        if not data[1] in seen_pids:
            appendWarningMessage("Received process termination event for "
                "process %s but process has never been seen!  Ignoring this termination" % data[1])
            return

        p_id = seen_pids[data[1]]
        cursor.execute("UPDATE process SET terminated_time = %s WHERE pid = %s AND terminated_time IS NULL AND id = %s" % (data[0], data[1], p_id))
        if cursor.rowcount == 1:
          #Since the process has been terminated, we shouldn't encounter any more DbgView logs about it
          #Let's confirm this by obfuscating its key so that we can later warn if
          #we see the pid being reused w/o an intervening create-process
          del seen_pids[data[1]]
          seen_pids["%s_%s" % (data[1], "terminated")] = p_id
        elif cursor.rowcount == 0:
            appendWarningMessage("Received a process-termination event but attempting to update an existing "
                                 "process's termination time failed.  There is no existing process with pid %s" % data[1])
        else:
            appendWarningMessage("Received a process-termination event but attempting to update an existing "
                                 "process's termination time failed.  There appears to be more than one existing "
                                 "process with the pid of %s!" % data[1])
    elif r_type == "image-load":
        # if the pid is not in seen_pids, then we've missed the process creation event
        # most likely the process was already running when we started DbgView
        if not data[2] in seen_pids:
            insert_unseen_process(data[2], data[0])
        if not data[3] in seen_pids:
            insert_unseen_process(data[3], data[0])

        file_name = normalize_filename(data[1])
        if not file_name in seen_file_resource_names:
            cursor.execute("INSERT INTO resource (name, first_seen, type) VALUES ('%s', %s, 'F')" % (file_name, data[0]))
            seen_file_resource_names[file_name] = cursor.lastrowid

        target_p_id = seen_pids[data[3]]
        p_id = seen_pids[data[2]]
        cursor.execute("INSERT INTO operation (p_id, target_p_id, r_id, op, time, data) VALUES (%s, %s, %s, 'IMAGE-LOAD', %s, '%s')" %
                           (target_p_id, p_id, seen_file_resource_names[file_name], data[0], data[4] ))
    elif r_type == "process-access-req":
        if not data[1] in seen_pids:
            insert_unseen_process(data[1], data[0])
        if not data[2] in seen_pids:
            insert_unseen_process(data[2], data[0])

        target_p_id = seen_pids[data[1]]
        p_id = seen_pids[data[2]]
        cursor.execute("INSERT INTO operation (p_id, target_p_id, op, time, data) VALUES (%s, %s, 'PROCESS-ACCESS-REQ', %s, '%s')" %
                           (p_id, target_p_id, data[0], data[3] ))
    elif r_type == "reg-set-key-value" or r_type == "reg-create-key" or r_type == "reg-delete-key" or r_type == "reg-delete-key-value" or r_type == "reg-rename-key":
        if r_type in ["reg-delete-key-value","reg-rename-key"]:
            '''
            annoyingly, unlike reg-set-key-value, the creator pid and data are swapped, account for this
            first convert the tuple to a list so we can modify it
            '''
            data = list(data)
            pid = data[3]
            data[3] = data[2]
            data[2] = pid

        key_name = normalize_regkey(data[1])
        if not data[2] in seen_pids:
            insert_unseen_process(data[2], data[0])
        if not key_name in seen_reg_resource_names:
            cursor.execute("INSERT INTO resource (name, first_seen, type) VALUES ('%s', %s, 'R')" % (key_name, data[0]))
            seen_reg_resource_names[key_name] = cursor.lastrowid

        if r_type in ["reg-set-key-value","reg-delete-key-value", "reg-rename-key"]:
            op = 'REG_SET_KEY_VALUE'
            if r_type == "reg-delete-key-value":
                op = 'REG_DELETE_KEY_VALUE'
            elif r_type == 'reg-rename-key':
                op = 'REG_RENAME_KEY'
            cursor.execute("INSERT INTO operation (p_id, r_id, op, time, data) VALUES (%s, %s, '%s', %s, '%s')" %
               (seen_pids[data[2]], seen_reg_resource_names[key_name], op, data[0], data[3]))
        else:
            op = 'REG_CREATE_KEY'
            if r_type == "reg-delete-key":
                op = 'REG_DELETE_KEY'
            cursor.execute("INSERT INTO operation (p_id, r_id, op, time) VALUES (%s, %s, '%s', %s)" %
               (seen_pids[data[2]], seen_reg_resource_names[key_name], op, data[0]))
    elif r_type.startswith("file_"):
        if not data[2] in seen_pids:
            insert_unseen_process(data[2], data[0])

        file_name = normalize_filename(data[3])
        if r_type in ["file_read", "file_write"]:
            file_name = normalize_filename(data[4])

        if not file_name in seen_file_resource_names:
            cursor.execute("INSERT INTO resource (name, first_seen, type) VALUES ('%s', %s, 'F')" % (file_name, data[0]))
            seen_file_resource_names[file_name] = cursor.lastrowid

        if r_type == "file_read":
            cursor.execute("INSERT INTO operation (p_id, r_id, op, time, data) VALUES (%s, %s, 'READ', %s, '%s')" %
                           (seen_pids[data[2]], seen_file_resource_names[file_name], data[0], data[3] ))
        elif r_type == "file_write":
            cursor.execute("INSERT INTO operation (p_id, r_id, op, time, data) VALUES (%s, %s, 'WRITE', %s, '%s')" %
                           (seen_pids[data[2]], seen_file_resource_names[file_name], data[0], data[3] ))
        elif r_type == "file_delete":
            cursor.execute("INSERT INTO operation (p_id, r_id, op, time) VALUES (%s, %s, 'DELETE', %s)" %
                           (seen_pids[data[2]], seen_file_resource_names[file_name], data[0]))
        elif r_type == "file_create":
            if data[4] == "FILE_DELETE_ON_CLOSE":
                cursor.execute("INSERT INTO operation (p_id, r_id, op, time) VALUES (%s, %s, 'DELETE', %s)" %
                               (seen_pids[data[2]], seen_file_resource_names[file_name], data[0]))
            else:
                cursor.execute("INSERT INTO operation (p_id, r_id, op, time, data) VALUES (%s, %s, 'CREATE', %s, '%s')" %
                               (seen_pids[data[2]], seen_file_resource_names[file_name], data[0], data[4] ))
    else:
        raise Exception("Unknown type, %s, data:  [%s]" % (r_type, ",".join(data)))


def initializeStateForNetworkLogs():
  global seen_pids, artifical_desc_address_count,warnings, cursor

  resp = cursor.execute("SELECT id, pid, desc_address FROM process ORDER BY id DESC")
  lastDescAddress = None
  for row in resp:
      seen_pids[row[1]] = row[0]
      lastDescAddress = row[2]

  if lastDescAddress:
    artifical_desc_address_count = int(lastDescAddress, 0) + 1
    return True
  else:
    return False


def build_database(conn, input_file):
    global drive_mappings, reused_pids, line_number, current_line, \
      showEmptyDBNetWarning, cursor

    reset()

    if not Path(input_file).is_file():
        sys.stderr.write("The input file, %s, is not a file or doesn't exist  \n" % input_file)
        return 2

    with(open("./drive_mappings.conf")) as f:
        for line in f:
            (key, val) = line.split("=")
            drive_mappings[key] = val.strip()

    cursor = conn.cursor()
    with open("./rsrc/schema.sql") as fp:
        cursor.executescript(fp.read())

    '''
    Parsing a netmon log file requires the corresponding DbgView
    log files to be first parsed.  This flag supports validating
    this requirement when the first netmon data type is detected
    in the logs that are being parsed.
    '''
    isInitializedForNetworkLogs = False
    showEmptyDBNetWarning = False
    with open(input_file, encoding="utf-8") as fp:
        current_line = fp.readline()
        line_number = 1
        while current_line:
          if current_line.strip():
            if "NetmonFilter" in current_line or "NetworkInfoEx" in current_line:
              pass
            else:
              ''' this is super inefficient but will do for now '''
              found = False
              for r_type, regex in DBGVIEW_REGEXES.items():
                  line_search = re.search(regex, current_line)
                  if(line_search):
                      if not isInitializedForNetworkLogs and "net-" in r_type:
                        isInitializedForNetworkLogs = True
                        if not initializeStateForNetworkLogs():
                          showEmptyDBNetWarning = True
                      try:
                        insertIntoDatabase(r_type, line_search.groups())
                      except:
                        if isInitializedForNetworkLogs:
                          appendNetWarningMessage("Exception occurred processing line: %s" %  (traceback.format_exc()))
                        else:
                          appendWarningMessage("Exception occurred processing line:  %s" % (traceback.format_exc()))

                      found = True
                      break

              if(not found):
                  print("***Error, Unmatched Line (%d):  %s\n" % (line_number, current_line))
                  break

          current_line = fp.readline()
          line_number += 1

          conn.commit()

def printResults():
    global cursor

    print("\n\n%d process ids were reused:  %s\n" % (len(reused_pids), ",".join(reused_pids)))
    if showEmptyDBNetWarning or warnings:
        print("\nErrors/Warnings:\n")
        if showEmptyDBNetWarning:
          print("The malware database is empty, and therefore network"
                   " operations cannot be linked to processes, did you"
                   " ensure that you parsed the DbgView logs first into the same DB?\n")
        if warnings:
          pprint.pprint(warnings)

    resp = cursor.execute("SELECT DISTINCT image FROM process WHERE image NOT LIKE '_:\%'");
    possibleUmappedFiles = []
    for row in resp:
        possibleUmappedFiles.append(row[0])

    if(len(possibleUmappedFiles)):
        print("\n\n****You have process image names in the log that may need to be mapped, "
              "i.e. doesn't begin with a drive letter, e.g. C:\ (see drive_mappings.conf).  Showing only first 20 .....\n");
        displayCount = 0
        for file in possibleUmappedFiles:
            print("%s\n" % file);
            displayCount += 1
            if displayCount == 20:
                break

    resp = cursor.execute("SELECT DISTINCT name FROM resource WHERE  type = 'F' AND name NOT LIKE '_:\%'");
    possibleUmappedFiles = []
    for row in resp:
        possibleUmappedFiles.append(row[0])

    if(len(possibleUmappedFiles)):
        print("\n\n****You have %d file resource names in the log that may need to be mapped, "
              "i.e. doesn't begin with a drive letter, e.g. C:\ (see drive_mappings.conf).  Showing only first 20 .....\n"
              % len(possibleUmappedFiles));
        displayCount = 0
        for file in possibleUmappedFiles:
            print("%s\n" % file);
            displayCount += 1
            if displayCount == 20:
                break

def buildMalwareDatabase(inputFiles, outputDbFile):
    conn = sqlite3.connect(outputDbFile)

    for pInput in inputFiles:
      print("\nBuilding database with input file %s\n" % pInput)
      build_database(conn, pInput)

    '''
    Try and attribute the DNS activity to processes based on IP address

    Gonna have to defer doing this as the netmon output is not showing the
    IP address as the destination address when connecting with an FQDN, but
    rather the FQDN!!!!
    '''
#     resp = cursor.execute("SELECT id, query_id, host FROM dns_operation WHERE op = 'RESPONSE' AND data = 'SUCCESS'").fetchall()
#     for row in resp:
#       p_id = cursor.execute("SELECT p_id FROM tcp_operation WHERE src_host = '%s' OR dst_host = '%s'" % (row[2], row[2])).fetchone()
#       print(p_id)
#       print(row)

    printResults()
    conn.close()

def main(argv=None): # IGNORE:C0111
    '''Command line options.'''

    global debug

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)
    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    program_license = '''%s

  Created by Nicholas Amon on %s.
  Copyright 2018 Amon Malware Consultants All rights reserved.

  Licensed under the Apache License 2.0
  http://www.apache.org/licenses/LICENSE-2.0

  Distributed on an "AS IS" basis without warranties
  or conditions of any kind, either express or implied.

USAGE
''' % (program_shortdesc, str(__date__))

    try:
        # Setup argument parser
        parser = ArgumentParser(description=program_license, formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-i", "--input", dest="input", nargs="*", action="append", help="the log file generated by DbgView", required=True )
        parser.add_argument("-o", "--output", dest="output", help="the name of the sqlite database to generate", required=True)
        parser.add_argument("-d", "--debug", dest="debug", help="debug mode", required=False, action='store_true')
        parser.add_argument('-V', '--version', action='version', version=program_version_message)

        # Process arguments
        args = parser.parse_args()

        debug = args.debug
        if debug:
            print("Verbose mode on")

        buildMalwareDatabase(args.input[0], args.output)

        return 0
    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0
    except Exception as e:
        raise(e)
        return 2

if __name__ == "__main__":
    sys.exit(main())